"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-minimal-pie-chart";
exports.ids = ["vendor-chunks/react-minimal-pie-chart"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-minimal-pie-chart/es/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/react-minimal-pie-chart/es/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PieChart: () => (/* binding */ ReactMinimalPieChart),\n/* harmony export */   pieChartDefaultProps: () => (/* binding */ defaultProps)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction degreesToRadians(degrees) {\n  return degrees * Math.PI / 180;\n}\nfunction valueBetween(value, min, max) {\n  if (value > max) return max;\n  if (value < min) return min;\n  return value;\n}\nfunction extractPercentage(value, percentage) {\n  return percentage / 100 * value;\n}\nfunction bisectorAngle(startAngle, lengthAngle) {\n  return startAngle + lengthAngle / 2;\n}\nfunction shiftVectorAlongAngle(angle, distance) {\n  var angleRadians = degreesToRadians(angle);\n  return {\n    dx: distance * Math.cos(angleRadians),\n    dy: distance * Math.sin(angleRadians)\n  };\n}\nfunction isNumber(value) {\n  return typeof value === 'number';\n}\nfunction functionProp(prop, payload) {\n  return typeof prop === 'function' ? prop(payload) : prop;\n}\nfunction makePropsWithDefaults(props, defaultProps) {\n  var result = Object.assign({}, defaultProps, props);\n\n  // @NOTE Object.assign doesn't default properties with undefined value (like React defaultProps does)\n  for (var key in defaultProps) {\n    if (props[key] === undefined) {\n      result[key] = defaultProps[key];\n    }\n  }\n  return result;\n}\n\nfunction sumValues(data) {\n  var sum = 0;\n  for (var i = 0; i < data.length; i++) {\n    sum += data[i].value;\n  }\n  return sum;\n}\n\n// Append \"percentage\", \"degrees\" and \"startAngle\" to each data entry\nfunction extendData(_ref) {\n  var data = _ref.data,\n    totalAngle = _ref.lengthAngle,\n    totalValue = _ref.totalValue,\n    paddingAngle = _ref.paddingAngle,\n    chartStartAngle = _ref.startAngle;\n  var total = totalValue || sumValues(data);\n  var normalizedTotalAngle = valueBetween(totalAngle, -360, 360);\n  var numberOfPaddings = Math.abs(normalizedTotalAngle) === 360 ? data.length : data.length - 1;\n  var singlePaddingDegrees = Math.abs(paddingAngle) * Math.sign(totalAngle);\n  var degreesTakenByPadding = singlePaddingDegrees * numberOfPaddings;\n  var degreesTakenByPaths = normalizedTotalAngle - degreesTakenByPadding;\n  var lastSegmentEnd = 0;\n  var extendedData = [];\n\n  // @NOTE: Shall we evaluate percentage accordingly to dataEntry.value's sign?\n  for (var i = 0; i < data.length; i++) {\n    var dataEntry = data[i];\n    var valueInPercentage = total === 0 ? 0 : dataEntry.value / total * 100;\n    var degrees = extractPercentage(degreesTakenByPaths, valueInPercentage);\n    var startAngle = lastSegmentEnd + chartStartAngle;\n    lastSegmentEnd = lastSegmentEnd + degrees + singlePaddingDegrees;\n    extendedData.push(Object.assign({\n      percentage: valueInPercentage,\n      startAngle: startAngle,\n      degrees: degrees\n    }, dataEntry));\n  }\n  return extendedData;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nfunction ReactMinimalPieChartLabel(_ref) {\n  var renderLabel = _ref.renderLabel,\n    labelProps = _ref.labelProps;\n  var label = renderLabel(labelProps);\n\n  // Default label\n  if (typeof label === 'string' || typeof label === 'number') {\n    labelProps.dataEntry;\n      labelProps.dataIndex;\n      var props = _objectWithoutPropertiesLoose(labelProps, [\"dataEntry\", \"dataIndex\"]);\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"text\", Object.assign({\n      dominantBaseline: \"central\"\n    }, props), label);\n  }\n  if (react__WEBPACK_IMPORTED_MODULE_0___default().isValidElement(label)) {\n    return label;\n  }\n  return null;\n}\n\nfunction round(number) {\n  var divisor = 1e14; // 14 decimals\n  return Math.round((number + Number.EPSILON) * divisor) / divisor;\n}\nfunction evaluateTextAnchorPosition(_ref) {\n  var labelPosition = _ref.labelPosition,\n    lineWidth = _ref.lineWidth,\n    labelHorizontalShift = _ref.labelHorizontalShift;\n  var dx = round(labelHorizontalShift);\n  // Label in the vertical center\n  if (dx === 0) {\n    return 'middle';\n  }\n  // Outward label\n  if (labelPosition > 100) {\n    return dx > 0 ? 'start' : 'end';\n  }\n  // Inward label\n  var innerRadius = 100 - lineWidth;\n  if (labelPosition < innerRadius) {\n    return dx > 0 ? 'end' : 'start';\n  }\n  // Overlying label\n  return 'middle';\n}\nfunction makeLabelRenderProps(data, props) {\n  return data.map(function (dataEntry, index) {\n    var _functionProp;\n    var segmentsShift = (_functionProp = functionProp(props.segmentsShift, index)) != null ? _functionProp : 0;\n    var distanceFromCenter = extractPercentage(props.radius, props.labelPosition) + segmentsShift;\n    var _shiftVectorAlongAngl = shiftVectorAlongAngle(bisectorAngle(dataEntry.startAngle, dataEntry.degrees), distanceFromCenter),\n      dx = _shiftVectorAlongAngl.dx,\n      dy = _shiftVectorAlongAngl.dy; // This object is passed as argument to the \"label\" function prop\n    var labelRenderProps = {\n      x: props.center[0],\n      y: props.center[1],\n      dx: dx,\n      dy: dy,\n      textAnchor: evaluateTextAnchorPosition({\n        labelPosition: props.labelPosition,\n        lineWidth: props.lineWidth,\n        labelHorizontalShift: dx\n      }),\n      dataEntry: dataEntry,\n      dataIndex: index,\n      style: functionProp(props.labelStyle, index)\n    };\n    return labelRenderProps;\n  });\n}\nfunction renderLabels(data, props) {\n  var label = props.label;\n  if (label) {\n    return makeLabelRenderProps(data, props).map(function (labelRenderProps, index) {\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ReactMinimalPieChartLabel, {\n        key: \"label-\" + (labelRenderProps.dataEntry.key || index),\n        renderLabel: label,\n        labelProps: labelRenderProps\n      });\n    });\n  }\n}\n\n// from http://stackoverflow.com/a/18473154\nvar partialCircle = function partialCircle(cx, cy, r, start, end) {\n  var length = end - start;\n  if (length === 0) return [];\n  var fromX = r * Math.cos(start) + cx;\n  var fromY = r * Math.sin(start) + cy;\n  var toX = r * Math.cos(end) + cx;\n  var toY = r * Math.sin(end) + cy;\n  var large = Math.abs(length) <= Math.PI ? '0' : '1';\n  var sweep = length < 0 ? '0' : '1';\n  return [['M', fromX, fromY], ['A', r, r, 0, large, sweep, toX, toY]];\n};\nvar svgPartialCircle = partialCircle;\n\nvar partialCircle$1 = svgPartialCircle;\n\nfunction makePathCommands(cx, cy, startAngle, lengthAngle, radius) {\n  var patchedLengthAngle = valueBetween(lengthAngle, -359.999, 359.999);\n  return partialCircle$1(cx, cy,\n  // center X and Y\n  radius, degreesToRadians(startAngle), degreesToRadians(startAngle + patchedLengthAngle)).map(function (command) {\n    return command.join(' ');\n  }).join(' ');\n}\nfunction ReactMinimalPieChartPath(_ref) {\n  var cx = _ref.cx,\n    cy = _ref.cy,\n    lengthAngle = _ref.lengthAngle,\n    lineWidth = _ref.lineWidth,\n    radius = _ref.radius,\n    _ref$shift = _ref.shift,\n    shift = _ref$shift === void 0 ? 0 : _ref$shift,\n    reveal = _ref.reveal,\n    rounded = _ref.rounded,\n    startAngle = _ref.startAngle,\n    title = _ref.title,\n    props = _objectWithoutPropertiesLoose(_ref, [\"cx\", \"cy\", \"lengthAngle\", \"lineWidth\", \"radius\", \"shift\", \"reveal\", \"rounded\", \"startAngle\", \"title\"]);\n  var pathRadius = radius - lineWidth / 2;\n  //@NOTE This shift might be rendered as a translation in future\n  var _shiftVectorAlongAngl = shiftVectorAlongAngle(bisectorAngle(startAngle, lengthAngle), shift),\n    dx = _shiftVectorAlongAngl.dx,\n    dy = _shiftVectorAlongAngl.dy;\n  var pathCommands = makePathCommands(cx + dx, cy + dy, startAngle, lengthAngle, pathRadius);\n  var strokeDasharray;\n  var strokeDashoffset;\n\n  // Animate/hide paths with \"stroke-dasharray\" + \"stroke-dashoffset\"\n  // https://css-tricks.com/svg-line-animation-works/\n  if (isNumber(reveal)) {\n    var pathLength = degreesToRadians(pathRadius) * lengthAngle;\n    strokeDasharray = Math.abs(pathLength);\n    strokeDashoffset = strokeDasharray - extractPercentage(strokeDasharray, reveal);\n  }\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", Object.assign({\n    d: pathCommands,\n    fill: \"none\",\n    strokeWidth: lineWidth,\n    strokeDasharray: strokeDasharray,\n    strokeDashoffset: strokeDashoffset,\n    strokeLinecap: rounded ? 'round' : undefined\n  }, props), title && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"title\", null, title));\n}\n\nfunction combineSegmentTransitionsStyle(duration, easing, customStyle) {\n  // Merge chart's animation CSS transition with \"transition\" found to customStyle\n  var transition = \"stroke-dashoffset \" + duration + \"ms \" + easing;\n  if (customStyle && customStyle.transition) {\n    transition = transition + \",\" + customStyle.transition;\n  }\n  return {\n    transition: transition\n  };\n}\nfunction getRevealValue(props) {\n  //@NOTE When animation is on, chart has to be fully revealed when reveal is not set\n  if (props.animate && !isNumber(props.reveal)) {\n    return 100;\n  }\n  return props.reveal;\n}\nfunction makeEventHandler(eventHandler, payload) {\n  return eventHandler && function (e) {\n    eventHandler(e, payload);\n  };\n}\nfunction renderSegments(data, props, revealOverride) {\n  // @NOTE this should go in Path component. Here for performance reasons\n  var reveal = revealOverride != null ? revealOverride : getRevealValue(props);\n  var radius = props.radius,\n    _props$center = props.center,\n    cx = _props$center[0],\n    cy = _props$center[1];\n  var lineWidth = extractPercentage(radius, props.lineWidth);\n  var paths = data.map(function (dataEntry, index) {\n    var segmentsStyle = functionProp(props.segmentsStyle, index);\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ReactMinimalPieChartPath, {\n      cx: cx,\n      cy: cy,\n      key: dataEntry.key || index,\n      lengthAngle: dataEntry.degrees,\n      lineWidth: lineWidth,\n      radius: radius,\n      rounded: props.rounded,\n      reveal: reveal,\n      shift: functionProp(props.segmentsShift, index),\n      startAngle: dataEntry.startAngle,\n      title: dataEntry.title,\n      style: Object.assign({}, segmentsStyle, props.animate && combineSegmentTransitionsStyle(props.animationDuration, props.animationEasing, segmentsStyle)),\n      stroke: dataEntry.color,\n      tabIndex: props.segmentsTabIndex,\n      onBlur: makeEventHandler(props.onBlur, index),\n      onClick: makeEventHandler(props.onClick, index),\n      onFocus: makeEventHandler(props.onFocus, index),\n      onKeyDown: makeEventHandler(props.onKeyDown, index),\n      onMouseOver: makeEventHandler(props.onMouseOver, index),\n      onMouseOut: makeEventHandler(props.onMouseOut, index)\n    });\n  });\n  if (props.background) {\n    paths.unshift( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ReactMinimalPieChartPath, {\n      cx: cx,\n      cy: cy,\n      key: \"bg\",\n      lengthAngle: props.lengthAngle,\n      lineWidth: lineWidth,\n      radius: radius,\n      rounded: props.rounded,\n      startAngle: props.startAngle,\n      stroke: props.background\n    }));\n  }\n  return paths;\n}\n\nvar defaultProps = {\n  animationDuration: 500,\n  animationEasing: 'ease-out',\n  center: [50, 50],\n  data: [],\n  labelPosition: 50,\n  lengthAngle: 360,\n  lineWidth: 100,\n  paddingAngle: 0,\n  radius: 50,\n  startAngle: 0,\n  viewBoxSize: [100, 100]\n};\nfunction ReactMinimalPieChart(originalProps) {\n  var props = makePropsWithDefaults(originalProps,\n  // @ts-expect-error: defaultProps.data is typed as BaseDataEntry\n  defaultProps);\n  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(props.animate ? 0 : null),\n    revealOverride = _useState[0],\n    setRevealOverride = _useState[1];\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    if (props.animate) {\n      // Trigger initial animation\n      setRevealOverride(null);\n    }\n  }, []);\n  var extendedData = extendData(props);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"svg\", {\n    viewBox: \"0 0 \" + props.viewBoxSize[0] + \" \" + props.viewBoxSize[1],\n    width: \"100%\",\n    height: \"100%\",\n    className: props.className,\n    style: props.style\n  }, renderSegments(extendedData, props, revealOverride), renderLabels(extendedData, props), props.children);\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWluaW1hbC1waWUtY2hhcnQvZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFtRDs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwREFBbUI7QUFDM0M7QUFDQSxLQUFLO0FBQ0w7QUFDQSxNQUFNLDJEQUFvQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwREFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwREFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxnQ0FBZ0MsMERBQW1CO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMERBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxnQ0FBZ0MsMERBQW1CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwrQ0FBUTtBQUMxQjtBQUNBO0FBQ0EsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esc0JBQXNCLDBEQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVrRjtBQUNsRiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250LWVuZC8uL25vZGVfbW9kdWxlcy9yZWFjdC1taW5pbWFsLXBpZS1jaGFydC9lcy9pbmRleC5qcz8wMTVhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG5mdW5jdGlvbiBkZWdyZWVzVG9SYWRpYW5zKGRlZ3JlZXMpIHtcbiAgcmV0dXJuIGRlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwO1xufVxuZnVuY3Rpb24gdmFsdWVCZXR3ZWVuKHZhbHVlLCBtaW4sIG1heCkge1xuICBpZiAodmFsdWUgPiBtYXgpIHJldHVybiBtYXg7XG4gIGlmICh2YWx1ZSA8IG1pbikgcmV0dXJuIG1pbjtcbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZXh0cmFjdFBlcmNlbnRhZ2UodmFsdWUsIHBlcmNlbnRhZ2UpIHtcbiAgcmV0dXJuIHBlcmNlbnRhZ2UgLyAxMDAgKiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGJpc2VjdG9yQW5nbGUoc3RhcnRBbmdsZSwgbGVuZ3RoQW5nbGUpIHtcbiAgcmV0dXJuIHN0YXJ0QW5nbGUgKyBsZW5ndGhBbmdsZSAvIDI7XG59XG5mdW5jdGlvbiBzaGlmdFZlY3RvckFsb25nQW5nbGUoYW5nbGUsIGRpc3RhbmNlKSB7XG4gIHZhciBhbmdsZVJhZGlhbnMgPSBkZWdyZWVzVG9SYWRpYW5zKGFuZ2xlKTtcbiAgcmV0dXJuIHtcbiAgICBkeDogZGlzdGFuY2UgKiBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpLFxuICAgIGR5OiBkaXN0YW5jZSAqIE1hdGguc2luKGFuZ2xlUmFkaWFucylcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xufVxuZnVuY3Rpb24gZnVuY3Rpb25Qcm9wKHByb3AsIHBheWxvYWQpIHtcbiAgcmV0dXJuIHR5cGVvZiBwcm9wID09PSAnZnVuY3Rpb24nID8gcHJvcChwYXlsb2FkKSA6IHByb3A7XG59XG5mdW5jdGlvbiBtYWtlUHJvcHNXaXRoRGVmYXVsdHMocHJvcHMsIGRlZmF1bHRQcm9wcykge1xuICB2YXIgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFByb3BzLCBwcm9wcyk7XG5cbiAgLy8gQE5PVEUgT2JqZWN0LmFzc2lnbiBkb2Vzbid0IGRlZmF1bHQgcHJvcGVydGllcyB3aXRoIHVuZGVmaW5lZCB2YWx1ZSAobGlrZSBSZWFjdCBkZWZhdWx0UHJvcHMgZG9lcylcbiAgZm9yICh2YXIga2V5IGluIGRlZmF1bHRQcm9wcykge1xuICAgIGlmIChwcm9wc1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gZGVmYXVsdFByb3BzW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHN1bVZhbHVlcyhkYXRhKSB7XG4gIHZhciBzdW0gPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBzdW0gKz0gZGF0YVtpXS52YWx1ZTtcbiAgfVxuICByZXR1cm4gc3VtO1xufVxuXG4vLyBBcHBlbmQgXCJwZXJjZW50YWdlXCIsIFwiZGVncmVlc1wiIGFuZCBcInN0YXJ0QW5nbGVcIiB0byBlYWNoIGRhdGEgZW50cnlcbmZ1bmN0aW9uIGV4dGVuZERhdGEoX3JlZikge1xuICB2YXIgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICB0b3RhbEFuZ2xlID0gX3JlZi5sZW5ndGhBbmdsZSxcbiAgICB0b3RhbFZhbHVlID0gX3JlZi50b3RhbFZhbHVlLFxuICAgIHBhZGRpbmdBbmdsZSA9IF9yZWYucGFkZGluZ0FuZ2xlLFxuICAgIGNoYXJ0U3RhcnRBbmdsZSA9IF9yZWYuc3RhcnRBbmdsZTtcbiAgdmFyIHRvdGFsID0gdG90YWxWYWx1ZSB8fCBzdW1WYWx1ZXMoZGF0YSk7XG4gIHZhciBub3JtYWxpemVkVG90YWxBbmdsZSA9IHZhbHVlQmV0d2Vlbih0b3RhbEFuZ2xlLCAtMzYwLCAzNjApO1xuICB2YXIgbnVtYmVyT2ZQYWRkaW5ncyA9IE1hdGguYWJzKG5vcm1hbGl6ZWRUb3RhbEFuZ2xlKSA9PT0gMzYwID8gZGF0YS5sZW5ndGggOiBkYXRhLmxlbmd0aCAtIDE7XG4gIHZhciBzaW5nbGVQYWRkaW5nRGVncmVlcyA9IE1hdGguYWJzKHBhZGRpbmdBbmdsZSkgKiBNYXRoLnNpZ24odG90YWxBbmdsZSk7XG4gIHZhciBkZWdyZWVzVGFrZW5CeVBhZGRpbmcgPSBzaW5nbGVQYWRkaW5nRGVncmVlcyAqIG51bWJlck9mUGFkZGluZ3M7XG4gIHZhciBkZWdyZWVzVGFrZW5CeVBhdGhzID0gbm9ybWFsaXplZFRvdGFsQW5nbGUgLSBkZWdyZWVzVGFrZW5CeVBhZGRpbmc7XG4gIHZhciBsYXN0U2VnbWVudEVuZCA9IDA7XG4gIHZhciBleHRlbmRlZERhdGEgPSBbXTtcblxuICAvLyBATk9URTogU2hhbGwgd2UgZXZhbHVhdGUgcGVyY2VudGFnZSBhY2NvcmRpbmdseSB0byBkYXRhRW50cnkudmFsdWUncyBzaWduP1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGF0YUVudHJ5ID0gZGF0YVtpXTtcbiAgICB2YXIgdmFsdWVJblBlcmNlbnRhZ2UgPSB0b3RhbCA9PT0gMCA/IDAgOiBkYXRhRW50cnkudmFsdWUgLyB0b3RhbCAqIDEwMDtcbiAgICB2YXIgZGVncmVlcyA9IGV4dHJhY3RQZXJjZW50YWdlKGRlZ3JlZXNUYWtlbkJ5UGF0aHMsIHZhbHVlSW5QZXJjZW50YWdlKTtcbiAgICB2YXIgc3RhcnRBbmdsZSA9IGxhc3RTZWdtZW50RW5kICsgY2hhcnRTdGFydEFuZ2xlO1xuICAgIGxhc3RTZWdtZW50RW5kID0gbGFzdFNlZ21lbnRFbmQgKyBkZWdyZWVzICsgc2luZ2xlUGFkZGluZ0RlZ3JlZXM7XG4gICAgZXh0ZW5kZWREYXRhLnB1c2goT2JqZWN0LmFzc2lnbih7XG4gICAgICBwZXJjZW50YWdlOiB2YWx1ZUluUGVyY2VudGFnZSxcbiAgICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgICBkZWdyZWVzOiBkZWdyZWVzXG4gICAgfSwgZGF0YUVudHJ5KSk7XG4gIH1cbiAgcmV0dXJuIGV4dGVuZGVkRGF0YTtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gUmVhY3RNaW5pbWFsUGllQ2hhcnRMYWJlbChfcmVmKSB7XG4gIHZhciByZW5kZXJMYWJlbCA9IF9yZWYucmVuZGVyTGFiZWwsXG4gICAgbGFiZWxQcm9wcyA9IF9yZWYubGFiZWxQcm9wcztcbiAgdmFyIGxhYmVsID0gcmVuZGVyTGFiZWwobGFiZWxQcm9wcyk7XG5cbiAgLy8gRGVmYXVsdCBsYWJlbFxuICBpZiAodHlwZW9mIGxhYmVsID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbGFiZWwgPT09ICdudW1iZXInKSB7XG4gICAgbGFiZWxQcm9wcy5kYXRhRW50cnk7XG4gICAgICBsYWJlbFByb3BzLmRhdGFJbmRleDtcbiAgICAgIHZhciBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKGxhYmVsUHJvcHMsIFtcImRhdGFFbnRyeVwiLCBcImRhdGFJbmRleFwiXSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwidGV4dFwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgIGRvbWluYW50QmFzZWxpbmU6IFwiY2VudHJhbFwiXG4gICAgfSwgcHJvcHMpLCBsYWJlbCk7XG4gIH1cbiAgaWYgKFJlYWN0LmlzVmFsaWRFbGVtZW50KGxhYmVsKSkge1xuICAgIHJldHVybiBsYWJlbDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcm91bmQobnVtYmVyKSB7XG4gIHZhciBkaXZpc29yID0gMWUxNDsgLy8gMTQgZGVjaW1hbHNcbiAgcmV0dXJuIE1hdGgucm91bmQoKG51bWJlciArIE51bWJlci5FUFNJTE9OKSAqIGRpdmlzb3IpIC8gZGl2aXNvcjtcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlVGV4dEFuY2hvclBvc2l0aW9uKF9yZWYpIHtcbiAgdmFyIGxhYmVsUG9zaXRpb24gPSBfcmVmLmxhYmVsUG9zaXRpb24sXG4gICAgbGluZVdpZHRoID0gX3JlZi5saW5lV2lkdGgsXG4gICAgbGFiZWxIb3Jpem9udGFsU2hpZnQgPSBfcmVmLmxhYmVsSG9yaXpvbnRhbFNoaWZ0O1xuICB2YXIgZHggPSByb3VuZChsYWJlbEhvcml6b250YWxTaGlmdCk7XG4gIC8vIExhYmVsIGluIHRoZSB2ZXJ0aWNhbCBjZW50ZXJcbiAgaWYgKGR4ID09PSAwKSB7XG4gICAgcmV0dXJuICdtaWRkbGUnO1xuICB9XG4gIC8vIE91dHdhcmQgbGFiZWxcbiAgaWYgKGxhYmVsUG9zaXRpb24gPiAxMDApIHtcbiAgICByZXR1cm4gZHggPiAwID8gJ3N0YXJ0JyA6ICdlbmQnO1xuICB9XG4gIC8vIElud2FyZCBsYWJlbFxuICB2YXIgaW5uZXJSYWRpdXMgPSAxMDAgLSBsaW5lV2lkdGg7XG4gIGlmIChsYWJlbFBvc2l0aW9uIDwgaW5uZXJSYWRpdXMpIHtcbiAgICByZXR1cm4gZHggPiAwID8gJ2VuZCcgOiAnc3RhcnQnO1xuICB9XG4gIC8vIE92ZXJseWluZyBsYWJlbFxuICByZXR1cm4gJ21pZGRsZSc7XG59XG5mdW5jdGlvbiBtYWtlTGFiZWxSZW5kZXJQcm9wcyhkYXRhLCBwcm9wcykge1xuICByZXR1cm4gZGF0YS5tYXAoZnVuY3Rpb24gKGRhdGFFbnRyeSwgaW5kZXgpIHtcbiAgICB2YXIgX2Z1bmN0aW9uUHJvcDtcbiAgICB2YXIgc2VnbWVudHNTaGlmdCA9IChfZnVuY3Rpb25Qcm9wID0gZnVuY3Rpb25Qcm9wKHByb3BzLnNlZ21lbnRzU2hpZnQsIGluZGV4KSkgIT0gbnVsbCA/IF9mdW5jdGlvblByb3AgOiAwO1xuICAgIHZhciBkaXN0YW5jZUZyb21DZW50ZXIgPSBleHRyYWN0UGVyY2VudGFnZShwcm9wcy5yYWRpdXMsIHByb3BzLmxhYmVsUG9zaXRpb24pICsgc2VnbWVudHNTaGlmdDtcbiAgICB2YXIgX3NoaWZ0VmVjdG9yQWxvbmdBbmdsID0gc2hpZnRWZWN0b3JBbG9uZ0FuZ2xlKGJpc2VjdG9yQW5nbGUoZGF0YUVudHJ5LnN0YXJ0QW5nbGUsIGRhdGFFbnRyeS5kZWdyZWVzKSwgZGlzdGFuY2VGcm9tQ2VudGVyKSxcbiAgICAgIGR4ID0gX3NoaWZ0VmVjdG9yQWxvbmdBbmdsLmR4LFxuICAgICAgZHkgPSBfc2hpZnRWZWN0b3JBbG9uZ0FuZ2wuZHk7IC8vIFRoaXMgb2JqZWN0IGlzIHBhc3NlZCBhcyBhcmd1bWVudCB0byB0aGUgXCJsYWJlbFwiIGZ1bmN0aW9uIHByb3BcbiAgICB2YXIgbGFiZWxSZW5kZXJQcm9wcyA9IHtcbiAgICAgIHg6IHByb3BzLmNlbnRlclswXSxcbiAgICAgIHk6IHByb3BzLmNlbnRlclsxXSxcbiAgICAgIGR4OiBkeCxcbiAgICAgIGR5OiBkeSxcbiAgICAgIHRleHRBbmNob3I6IGV2YWx1YXRlVGV4dEFuY2hvclBvc2l0aW9uKHtcbiAgICAgICAgbGFiZWxQb3NpdGlvbjogcHJvcHMubGFiZWxQb3NpdGlvbixcbiAgICAgICAgbGluZVdpZHRoOiBwcm9wcy5saW5lV2lkdGgsXG4gICAgICAgIGxhYmVsSG9yaXpvbnRhbFNoaWZ0OiBkeFxuICAgICAgfSksXG4gICAgICBkYXRhRW50cnk6IGRhdGFFbnRyeSxcbiAgICAgIGRhdGFJbmRleDogaW5kZXgsXG4gICAgICBzdHlsZTogZnVuY3Rpb25Qcm9wKHByb3BzLmxhYmVsU3R5bGUsIGluZGV4KVxuICAgIH07XG4gICAgcmV0dXJuIGxhYmVsUmVuZGVyUHJvcHM7XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVuZGVyTGFiZWxzKGRhdGEsIHByb3BzKSB7XG4gIHZhciBsYWJlbCA9IHByb3BzLmxhYmVsO1xuICBpZiAobGFiZWwpIHtcbiAgICByZXR1cm4gbWFrZUxhYmVsUmVuZGVyUHJvcHMoZGF0YSwgcHJvcHMpLm1hcChmdW5jdGlvbiAobGFiZWxSZW5kZXJQcm9wcywgaW5kZXgpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdE1pbmltYWxQaWVDaGFydExhYmVsLCB7XG4gICAgICAgIGtleTogXCJsYWJlbC1cIiArIChsYWJlbFJlbmRlclByb3BzLmRhdGFFbnRyeS5rZXkgfHwgaW5kZXgpLFxuICAgICAgICByZW5kZXJMYWJlbDogbGFiZWwsXG4gICAgICAgIGxhYmVsUHJvcHM6IGxhYmVsUmVuZGVyUHJvcHNcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5cbi8vIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTg0NzMxNTRcbnZhciBwYXJ0aWFsQ2lyY2xlID0gZnVuY3Rpb24gcGFydGlhbENpcmNsZShjeCwgY3ksIHIsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbmd0aCA9IGVuZCAtIHN0YXJ0O1xuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gW107XG4gIHZhciBmcm9tWCA9IHIgKiBNYXRoLmNvcyhzdGFydCkgKyBjeDtcbiAgdmFyIGZyb21ZID0gciAqIE1hdGguc2luKHN0YXJ0KSArIGN5O1xuICB2YXIgdG9YID0gciAqIE1hdGguY29zKGVuZCkgKyBjeDtcbiAgdmFyIHRvWSA9IHIgKiBNYXRoLnNpbihlbmQpICsgY3k7XG4gIHZhciBsYXJnZSA9IE1hdGguYWJzKGxlbmd0aCkgPD0gTWF0aC5QSSA/ICcwJyA6ICcxJztcbiAgdmFyIHN3ZWVwID0gbGVuZ3RoIDwgMCA/ICcwJyA6ICcxJztcbiAgcmV0dXJuIFtbJ00nLCBmcm9tWCwgZnJvbVldLCBbJ0EnLCByLCByLCAwLCBsYXJnZSwgc3dlZXAsIHRvWCwgdG9ZXV07XG59O1xudmFyIHN2Z1BhcnRpYWxDaXJjbGUgPSBwYXJ0aWFsQ2lyY2xlO1xuXG52YXIgcGFydGlhbENpcmNsZSQxID0gc3ZnUGFydGlhbENpcmNsZTtcblxuZnVuY3Rpb24gbWFrZVBhdGhDb21tYW5kcyhjeCwgY3ksIHN0YXJ0QW5nbGUsIGxlbmd0aEFuZ2xlLCByYWRpdXMpIHtcbiAgdmFyIHBhdGNoZWRMZW5ndGhBbmdsZSA9IHZhbHVlQmV0d2VlbihsZW5ndGhBbmdsZSwgLTM1OS45OTksIDM1OS45OTkpO1xuICByZXR1cm4gcGFydGlhbENpcmNsZSQxKGN4LCBjeSxcbiAgLy8gY2VudGVyIFggYW5kIFlcbiAgcmFkaXVzLCBkZWdyZWVzVG9SYWRpYW5zKHN0YXJ0QW5nbGUpLCBkZWdyZWVzVG9SYWRpYW5zKHN0YXJ0QW5nbGUgKyBwYXRjaGVkTGVuZ3RoQW5nbGUpKS5tYXAoZnVuY3Rpb24gKGNvbW1hbmQpIHtcbiAgICByZXR1cm4gY29tbWFuZC5qb2luKCcgJyk7XG4gIH0pLmpvaW4oJyAnKTtcbn1cbmZ1bmN0aW9uIFJlYWN0TWluaW1hbFBpZUNoYXJ0UGF0aChfcmVmKSB7XG4gIHZhciBjeCA9IF9yZWYuY3gsXG4gICAgY3kgPSBfcmVmLmN5LFxuICAgIGxlbmd0aEFuZ2xlID0gX3JlZi5sZW5ndGhBbmdsZSxcbiAgICBsaW5lV2lkdGggPSBfcmVmLmxpbmVXaWR0aCxcbiAgICByYWRpdXMgPSBfcmVmLnJhZGl1cyxcbiAgICBfcmVmJHNoaWZ0ID0gX3JlZi5zaGlmdCxcbiAgICBzaGlmdCA9IF9yZWYkc2hpZnQgPT09IHZvaWQgMCA/IDAgOiBfcmVmJHNoaWZ0LFxuICAgIHJldmVhbCA9IF9yZWYucmV2ZWFsLFxuICAgIHJvdW5kZWQgPSBfcmVmLnJvdW5kZWQsXG4gICAgc3RhcnRBbmdsZSA9IF9yZWYuc3RhcnRBbmdsZSxcbiAgICB0aXRsZSA9IF9yZWYudGl0bGUsXG4gICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBbXCJjeFwiLCBcImN5XCIsIFwibGVuZ3RoQW5nbGVcIiwgXCJsaW5lV2lkdGhcIiwgXCJyYWRpdXNcIiwgXCJzaGlmdFwiLCBcInJldmVhbFwiLCBcInJvdW5kZWRcIiwgXCJzdGFydEFuZ2xlXCIsIFwidGl0bGVcIl0pO1xuICB2YXIgcGF0aFJhZGl1cyA9IHJhZGl1cyAtIGxpbmVXaWR0aCAvIDI7XG4gIC8vQE5PVEUgVGhpcyBzaGlmdCBtaWdodCBiZSByZW5kZXJlZCBhcyBhIHRyYW5zbGF0aW9uIGluIGZ1dHVyZVxuICB2YXIgX3NoaWZ0VmVjdG9yQWxvbmdBbmdsID0gc2hpZnRWZWN0b3JBbG9uZ0FuZ2xlKGJpc2VjdG9yQW5nbGUoc3RhcnRBbmdsZSwgbGVuZ3RoQW5nbGUpLCBzaGlmdCksXG4gICAgZHggPSBfc2hpZnRWZWN0b3JBbG9uZ0FuZ2wuZHgsXG4gICAgZHkgPSBfc2hpZnRWZWN0b3JBbG9uZ0FuZ2wuZHk7XG4gIHZhciBwYXRoQ29tbWFuZHMgPSBtYWtlUGF0aENvbW1hbmRzKGN4ICsgZHgsIGN5ICsgZHksIHN0YXJ0QW5nbGUsIGxlbmd0aEFuZ2xlLCBwYXRoUmFkaXVzKTtcbiAgdmFyIHN0cm9rZURhc2hhcnJheTtcbiAgdmFyIHN0cm9rZURhc2hvZmZzZXQ7XG5cbiAgLy8gQW5pbWF0ZS9oaWRlIHBhdGhzIHdpdGggXCJzdHJva2UtZGFzaGFycmF5XCIgKyBcInN0cm9rZS1kYXNob2Zmc2V0XCJcbiAgLy8gaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9zdmctbGluZS1hbmltYXRpb24td29ya3MvXG4gIGlmIChpc051bWJlcihyZXZlYWwpKSB7XG4gICAgdmFyIHBhdGhMZW5ndGggPSBkZWdyZWVzVG9SYWRpYW5zKHBhdGhSYWRpdXMpICogbGVuZ3RoQW5nbGU7XG4gICAgc3Ryb2tlRGFzaGFycmF5ID0gTWF0aC5hYnMocGF0aExlbmd0aCk7XG4gICAgc3Ryb2tlRGFzaG9mZnNldCA9IHN0cm9rZURhc2hhcnJheSAtIGV4dHJhY3RQZXJjZW50YWdlKHN0cm9rZURhc2hhcnJheSwgcmV2ZWFsKTtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIGQ6IHBhdGhDb21tYW5kcyxcbiAgICBmaWxsOiBcIm5vbmVcIixcbiAgICBzdHJva2VXaWR0aDogbGluZVdpZHRoLFxuICAgIHN0cm9rZURhc2hhcnJheTogc3Ryb2tlRGFzaGFycmF5LFxuICAgIHN0cm9rZURhc2hvZmZzZXQ6IHN0cm9rZURhc2hvZmZzZXQsXG4gICAgc3Ryb2tlTGluZWNhcDogcm91bmRlZCA/ICdyb3VuZCcgOiB1bmRlZmluZWRcbiAgfSwgcHJvcHMpLCB0aXRsZSAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInRpdGxlXCIsIG51bGwsIHRpdGxlKSk7XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVTZWdtZW50VHJhbnNpdGlvbnNTdHlsZShkdXJhdGlvbiwgZWFzaW5nLCBjdXN0b21TdHlsZSkge1xuICAvLyBNZXJnZSBjaGFydCdzIGFuaW1hdGlvbiBDU1MgdHJhbnNpdGlvbiB3aXRoIFwidHJhbnNpdGlvblwiIGZvdW5kIHRvIGN1c3RvbVN0eWxlXG4gIHZhciB0cmFuc2l0aW9uID0gXCJzdHJva2UtZGFzaG9mZnNldCBcIiArIGR1cmF0aW9uICsgXCJtcyBcIiArIGVhc2luZztcbiAgaWYgKGN1c3RvbVN0eWxlICYmIGN1c3RvbVN0eWxlLnRyYW5zaXRpb24pIHtcbiAgICB0cmFuc2l0aW9uID0gdHJhbnNpdGlvbiArIFwiLFwiICsgY3VzdG9tU3R5bGUudHJhbnNpdGlvbjtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb25cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFJldmVhbFZhbHVlKHByb3BzKSB7XG4gIC8vQE5PVEUgV2hlbiBhbmltYXRpb24gaXMgb24sIGNoYXJ0IGhhcyB0byBiZSBmdWxseSByZXZlYWxlZCB3aGVuIHJldmVhbCBpcyBub3Qgc2V0XG4gIGlmIChwcm9wcy5hbmltYXRlICYmICFpc051bWJlcihwcm9wcy5yZXZlYWwpKSB7XG4gICAgcmV0dXJuIDEwMDtcbiAgfVxuICByZXR1cm4gcHJvcHMucmV2ZWFsO1xufVxuZnVuY3Rpb24gbWFrZUV2ZW50SGFuZGxlcihldmVudEhhbmRsZXIsIHBheWxvYWQpIHtcbiAgcmV0dXJuIGV2ZW50SGFuZGxlciAmJiBmdW5jdGlvbiAoZSkge1xuICAgIGV2ZW50SGFuZGxlcihlLCBwYXlsb2FkKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlbmRlclNlZ21lbnRzKGRhdGEsIHByb3BzLCByZXZlYWxPdmVycmlkZSkge1xuICAvLyBATk9URSB0aGlzIHNob3VsZCBnbyBpbiBQYXRoIGNvbXBvbmVudC4gSGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xuICB2YXIgcmV2ZWFsID0gcmV2ZWFsT3ZlcnJpZGUgIT0gbnVsbCA/IHJldmVhbE92ZXJyaWRlIDogZ2V0UmV2ZWFsVmFsdWUocHJvcHMpO1xuICB2YXIgcmFkaXVzID0gcHJvcHMucmFkaXVzLFxuICAgIF9wcm9wcyRjZW50ZXIgPSBwcm9wcy5jZW50ZXIsXG4gICAgY3ggPSBfcHJvcHMkY2VudGVyWzBdLFxuICAgIGN5ID0gX3Byb3BzJGNlbnRlclsxXTtcbiAgdmFyIGxpbmVXaWR0aCA9IGV4dHJhY3RQZXJjZW50YWdlKHJhZGl1cywgcHJvcHMubGluZVdpZHRoKTtcbiAgdmFyIHBhdGhzID0gZGF0YS5tYXAoZnVuY3Rpb24gKGRhdGFFbnRyeSwgaW5kZXgpIHtcbiAgICB2YXIgc2VnbWVudHNTdHlsZSA9IGZ1bmN0aW9uUHJvcChwcm9wcy5zZWdtZW50c1N0eWxlLCBpbmRleCk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0TWluaW1hbFBpZUNoYXJ0UGF0aCwge1xuICAgICAgY3g6IGN4LFxuICAgICAgY3k6IGN5LFxuICAgICAga2V5OiBkYXRhRW50cnkua2V5IHx8IGluZGV4LFxuICAgICAgbGVuZ3RoQW5nbGU6IGRhdGFFbnRyeS5kZWdyZWVzLFxuICAgICAgbGluZVdpZHRoOiBsaW5lV2lkdGgsXG4gICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgIHJvdW5kZWQ6IHByb3BzLnJvdW5kZWQsXG4gICAgICByZXZlYWw6IHJldmVhbCxcbiAgICAgIHNoaWZ0OiBmdW5jdGlvblByb3AocHJvcHMuc2VnbWVudHNTaGlmdCwgaW5kZXgpLFxuICAgICAgc3RhcnRBbmdsZTogZGF0YUVudHJ5LnN0YXJ0QW5nbGUsXG4gICAgICB0aXRsZTogZGF0YUVudHJ5LnRpdGxlLFxuICAgICAgc3R5bGU6IE9iamVjdC5hc3NpZ24oe30sIHNlZ21lbnRzU3R5bGUsIHByb3BzLmFuaW1hdGUgJiYgY29tYmluZVNlZ21lbnRUcmFuc2l0aW9uc1N0eWxlKHByb3BzLmFuaW1hdGlvbkR1cmF0aW9uLCBwcm9wcy5hbmltYXRpb25FYXNpbmcsIHNlZ21lbnRzU3R5bGUpKSxcbiAgICAgIHN0cm9rZTogZGF0YUVudHJ5LmNvbG9yLFxuICAgICAgdGFiSW5kZXg6IHByb3BzLnNlZ21lbnRzVGFiSW5kZXgsXG4gICAgICBvbkJsdXI6IG1ha2VFdmVudEhhbmRsZXIocHJvcHMub25CbHVyLCBpbmRleCksXG4gICAgICBvbkNsaWNrOiBtYWtlRXZlbnRIYW5kbGVyKHByb3BzLm9uQ2xpY2ssIGluZGV4KSxcbiAgICAgIG9uRm9jdXM6IG1ha2VFdmVudEhhbmRsZXIocHJvcHMub25Gb2N1cywgaW5kZXgpLFxuICAgICAgb25LZXlEb3duOiBtYWtlRXZlbnRIYW5kbGVyKHByb3BzLm9uS2V5RG93biwgaW5kZXgpLFxuICAgICAgb25Nb3VzZU92ZXI6IG1ha2VFdmVudEhhbmRsZXIocHJvcHMub25Nb3VzZU92ZXIsIGluZGV4KSxcbiAgICAgIG9uTW91c2VPdXQ6IG1ha2VFdmVudEhhbmRsZXIocHJvcHMub25Nb3VzZU91dCwgaW5kZXgpXG4gICAgfSk7XG4gIH0pO1xuICBpZiAocHJvcHMuYmFja2dyb3VuZCkge1xuICAgIHBhdGhzLnVuc2hpZnQoIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0TWluaW1hbFBpZUNoYXJ0UGF0aCwge1xuICAgICAgY3g6IGN4LFxuICAgICAgY3k6IGN5LFxuICAgICAga2V5OiBcImJnXCIsXG4gICAgICBsZW5ndGhBbmdsZTogcHJvcHMubGVuZ3RoQW5nbGUsXG4gICAgICBsaW5lV2lkdGg6IGxpbmVXaWR0aCxcbiAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgcm91bmRlZDogcHJvcHMucm91bmRlZCxcbiAgICAgIHN0YXJ0QW5nbGU6IHByb3BzLnN0YXJ0QW5nbGUsXG4gICAgICBzdHJva2U6IHByb3BzLmJhY2tncm91bmRcbiAgICB9KSk7XG4gIH1cbiAgcmV0dXJuIHBhdGhzO1xufVxuXG52YXIgZGVmYXVsdFByb3BzID0ge1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxuICBhbmltYXRpb25FYXNpbmc6ICdlYXNlLW91dCcsXG4gIGNlbnRlcjogWzUwLCA1MF0sXG4gIGRhdGE6IFtdLFxuICBsYWJlbFBvc2l0aW9uOiA1MCxcbiAgbGVuZ3RoQW5nbGU6IDM2MCxcbiAgbGluZVdpZHRoOiAxMDAsXG4gIHBhZGRpbmdBbmdsZTogMCxcbiAgcmFkaXVzOiA1MCxcbiAgc3RhcnRBbmdsZTogMCxcbiAgdmlld0JveFNpemU6IFsxMDAsIDEwMF1cbn07XG5mdW5jdGlvbiBSZWFjdE1pbmltYWxQaWVDaGFydChvcmlnaW5hbFByb3BzKSB7XG4gIHZhciBwcm9wcyA9IG1ha2VQcm9wc1dpdGhEZWZhdWx0cyhvcmlnaW5hbFByb3BzLFxuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBkZWZhdWx0UHJvcHMuZGF0YSBpcyB0eXBlZCBhcyBCYXNlRGF0YUVudHJ5XG4gIGRlZmF1bHRQcm9wcyk7XG4gIHZhciBfdXNlU3RhdGUgPSB1c2VTdGF0ZShwcm9wcy5hbmltYXRlID8gMCA6IG51bGwpLFxuICAgIHJldmVhbE92ZXJyaWRlID0gX3VzZVN0YXRlWzBdLFxuICAgIHNldFJldmVhbE92ZXJyaWRlID0gX3VzZVN0YXRlWzFdO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChwcm9wcy5hbmltYXRlKSB7XG4gICAgICAvLyBUcmlnZ2VyIGluaXRpYWwgYW5pbWF0aW9uXG4gICAgICBzZXRSZXZlYWxPdmVycmlkZShudWxsKTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgdmFyIGV4dGVuZGVkRGF0YSA9IGV4dGVuZERhdGEocHJvcHMpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwge1xuICAgIHZpZXdCb3g6IFwiMCAwIFwiICsgcHJvcHMudmlld0JveFNpemVbMF0gKyBcIiBcIiArIHByb3BzLnZpZXdCb3hTaXplWzFdLFxuICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgIGNsYXNzTmFtZTogcHJvcHMuY2xhc3NOYW1lLFxuICAgIHN0eWxlOiBwcm9wcy5zdHlsZVxuICB9LCByZW5kZXJTZWdtZW50cyhleHRlbmRlZERhdGEsIHByb3BzLCByZXZlYWxPdmVycmlkZSksIHJlbmRlckxhYmVscyhleHRlbmRlZERhdGEsIHByb3BzKSwgcHJvcHMuY2hpbGRyZW4pO1xufVxuXG5leHBvcnQgeyBSZWFjdE1pbmltYWxQaWVDaGFydCBhcyBQaWVDaGFydCwgZGVmYXVsdFByb3BzIGFzIHBpZUNoYXJ0RGVmYXVsdFByb3BzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-minimal-pie-chart/es/index.js\n");

/***/ })

};
;