/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashBoard/page",{

/***/ "(app-pages-browser)/./node_modules/react-minimal-pie-chart/dist/index.js":
/*!************************************************************!*\
  !*** ./node_modules/react-minimal-pie-chart/dist/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\")) :\n  0;\n})(this, (function (exports, React) { 'use strict';\n\n  function degreesToRadians(degrees) {\n    return degrees * Math.PI / 180;\n  }\n  function valueBetween(value, min, max) {\n    if (value > max) return max;\n    if (value < min) return min;\n    return value;\n  }\n  function extractPercentage(value, percentage) {\n    return percentage / 100 * value;\n  }\n  function bisectorAngle(startAngle, lengthAngle) {\n    return startAngle + lengthAngle / 2;\n  }\n  function shiftVectorAlongAngle(angle, distance) {\n    var angleRadians = degreesToRadians(angle);\n    return {\n      dx: distance * Math.cos(angleRadians),\n      dy: distance * Math.sin(angleRadians)\n    };\n  }\n  function isNumber(value) {\n    return typeof value === 'number';\n  }\n  function functionProp(prop, payload) {\n    return typeof prop === 'function' ? prop(payload) : prop;\n  }\n  function makePropsWithDefaults(props, defaultProps) {\n    var result = Object.assign({}, defaultProps, props);\n\n    // @NOTE Object.assign doesn't default properties with undefined value (like React defaultProps does)\n    for (var key in defaultProps) {\n      if (props[key] === undefined) {\n        result[key] = defaultProps[key];\n      }\n    }\n    return result;\n  }\n\n  function sumValues(data) {\n    var sum = 0;\n    for (var i = 0; i < data.length; i++) {\n      sum += data[i].value;\n    }\n    return sum;\n  }\n\n  // Append \"percentage\", \"degrees\" and \"startAngle\" to each data entry\n  function extendData(_ref) {\n    var data = _ref.data,\n      totalAngle = _ref.lengthAngle,\n      totalValue = _ref.totalValue,\n      paddingAngle = _ref.paddingAngle,\n      chartStartAngle = _ref.startAngle;\n    var total = totalValue || sumValues(data);\n    var normalizedTotalAngle = valueBetween(totalAngle, -360, 360);\n    var numberOfPaddings = Math.abs(normalizedTotalAngle) === 360 ? data.length : data.length - 1;\n    var singlePaddingDegrees = Math.abs(paddingAngle) * Math.sign(totalAngle);\n    var degreesTakenByPadding = singlePaddingDegrees * numberOfPaddings;\n    var degreesTakenByPaths = normalizedTotalAngle - degreesTakenByPadding;\n    var lastSegmentEnd = 0;\n    var extendedData = [];\n\n    // @NOTE: Shall we evaluate percentage accordingly to dataEntry.value's sign?\n    for (var i = 0; i < data.length; i++) {\n      var dataEntry = data[i];\n      var valueInPercentage = total === 0 ? 0 : dataEntry.value / total * 100;\n      var degrees = extractPercentage(degreesTakenByPaths, valueInPercentage);\n      var startAngle = lastSegmentEnd + chartStartAngle;\n      lastSegmentEnd = lastSegmentEnd + degrees + singlePaddingDegrees;\n      extendedData.push(Object.assign({\n        percentage: valueInPercentage,\n        startAngle: startAngle,\n        degrees: degrees\n      }, dataEntry));\n    }\n    return extendedData;\n  }\n\n  function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n    return target;\n  }\n\n  function ReactMinimalPieChartLabel(_ref) {\n    var renderLabel = _ref.renderLabel,\n      labelProps = _ref.labelProps;\n    var label = renderLabel(labelProps);\n\n    // Default label\n    if (typeof label === 'string' || typeof label === 'number') {\n      labelProps.dataEntry;\n        labelProps.dataIndex;\n        var props = _objectWithoutPropertiesLoose(labelProps, [\"dataEntry\", \"dataIndex\"]);\n      return /*#__PURE__*/React.createElement(\"text\", Object.assign({\n        dominantBaseline: \"central\"\n      }, props), label);\n    }\n    if (React.isValidElement(label)) {\n      return label;\n    }\n    return null;\n  }\n\n  function round(number) {\n    var divisor = 1e14; // 14 decimals\n    return Math.round((number + Number.EPSILON) * divisor) / divisor;\n  }\n  function evaluateTextAnchorPosition(_ref) {\n    var labelPosition = _ref.labelPosition,\n      lineWidth = _ref.lineWidth,\n      labelHorizontalShift = _ref.labelHorizontalShift;\n    var dx = round(labelHorizontalShift);\n    // Label in the vertical center\n    if (dx === 0) {\n      return 'middle';\n    }\n    // Outward label\n    if (labelPosition > 100) {\n      return dx > 0 ? 'start' : 'end';\n    }\n    // Inward label\n    var innerRadius = 100 - lineWidth;\n    if (labelPosition < innerRadius) {\n      return dx > 0 ? 'end' : 'start';\n    }\n    // Overlying label\n    return 'middle';\n  }\n  function makeLabelRenderProps(data, props) {\n    return data.map(function (dataEntry, index) {\n      var _functionProp;\n      var segmentsShift = (_functionProp = functionProp(props.segmentsShift, index)) != null ? _functionProp : 0;\n      var distanceFromCenter = extractPercentage(props.radius, props.labelPosition) + segmentsShift;\n      var _shiftVectorAlongAngl = shiftVectorAlongAngle(bisectorAngle(dataEntry.startAngle, dataEntry.degrees), distanceFromCenter),\n        dx = _shiftVectorAlongAngl.dx,\n        dy = _shiftVectorAlongAngl.dy; // This object is passed as argument to the \"label\" function prop\n      var labelRenderProps = {\n        x: props.center[0],\n        y: props.center[1],\n        dx: dx,\n        dy: dy,\n        textAnchor: evaluateTextAnchorPosition({\n          labelPosition: props.labelPosition,\n          lineWidth: props.lineWidth,\n          labelHorizontalShift: dx\n        }),\n        dataEntry: dataEntry,\n        dataIndex: index,\n        style: functionProp(props.labelStyle, index)\n      };\n      return labelRenderProps;\n    });\n  }\n  function renderLabels(data, props) {\n    var label = props.label;\n    if (label) {\n      return makeLabelRenderProps(data, props).map(function (labelRenderProps, index) {\n        return /*#__PURE__*/React.createElement(ReactMinimalPieChartLabel, {\n          key: \"label-\" + (labelRenderProps.dataEntry.key || index),\n          renderLabel: label,\n          labelProps: labelRenderProps\n        });\n      });\n    }\n  }\n\n  // from http://stackoverflow.com/a/18473154\n  var partialCircle = function partialCircle(cx, cy, r, start, end) {\n    var length = end - start;\n    if (length === 0) return [];\n    var fromX = r * Math.cos(start) + cx;\n    var fromY = r * Math.sin(start) + cy;\n    var toX = r * Math.cos(end) + cx;\n    var toY = r * Math.sin(end) + cy;\n    var large = Math.abs(length) <= Math.PI ? '0' : '1';\n    var sweep = length < 0 ? '0' : '1';\n    return [['M', fromX, fromY], ['A', r, r, 0, large, sweep, toX, toY]];\n  };\n  var svgPartialCircle = partialCircle;\n\n  var partialCircle$1 = svgPartialCircle;\n\n  function makePathCommands(cx, cy, startAngle, lengthAngle, radius) {\n    var patchedLengthAngle = valueBetween(lengthAngle, -359.999, 359.999);\n    return partialCircle$1(cx, cy,\n    // center X and Y\n    radius, degreesToRadians(startAngle), degreesToRadians(startAngle + patchedLengthAngle)).map(function (command) {\n      return command.join(' ');\n    }).join(' ');\n  }\n  function ReactMinimalPieChartPath(_ref) {\n    var cx = _ref.cx,\n      cy = _ref.cy,\n      lengthAngle = _ref.lengthAngle,\n      lineWidth = _ref.lineWidth,\n      radius = _ref.radius,\n      _ref$shift = _ref.shift,\n      shift = _ref$shift === void 0 ? 0 : _ref$shift,\n      reveal = _ref.reveal,\n      rounded = _ref.rounded,\n      startAngle = _ref.startAngle,\n      title = _ref.title,\n      props = _objectWithoutPropertiesLoose(_ref, [\"cx\", \"cy\", \"lengthAngle\", \"lineWidth\", \"radius\", \"shift\", \"reveal\", \"rounded\", \"startAngle\", \"title\"]);\n    var pathRadius = radius - lineWidth / 2;\n    //@NOTE This shift might be rendered as a translation in future\n    var _shiftVectorAlongAngl = shiftVectorAlongAngle(bisectorAngle(startAngle, lengthAngle), shift),\n      dx = _shiftVectorAlongAngl.dx,\n      dy = _shiftVectorAlongAngl.dy;\n    var pathCommands = makePathCommands(cx + dx, cy + dy, startAngle, lengthAngle, pathRadius);\n    var strokeDasharray;\n    var strokeDashoffset;\n\n    // Animate/hide paths with \"stroke-dasharray\" + \"stroke-dashoffset\"\n    // https://css-tricks.com/svg-line-animation-works/\n    if (isNumber(reveal)) {\n      var pathLength = degreesToRadians(pathRadius) * lengthAngle;\n      strokeDasharray = Math.abs(pathLength);\n      strokeDashoffset = strokeDasharray - extractPercentage(strokeDasharray, reveal);\n    }\n    return /*#__PURE__*/React.createElement(\"path\", Object.assign({\n      d: pathCommands,\n      fill: \"none\",\n      strokeWidth: lineWidth,\n      strokeDasharray: strokeDasharray,\n      strokeDashoffset: strokeDashoffset,\n      strokeLinecap: rounded ? 'round' : undefined\n    }, props), title && /*#__PURE__*/React.createElement(\"title\", null, title));\n  }\n\n  function combineSegmentTransitionsStyle(duration, easing, customStyle) {\n    // Merge chart's animation CSS transition with \"transition\" found to customStyle\n    var transition = \"stroke-dashoffset \" + duration + \"ms \" + easing;\n    if (customStyle && customStyle.transition) {\n      transition = transition + \",\" + customStyle.transition;\n    }\n    return {\n      transition: transition\n    };\n  }\n  function getRevealValue(props) {\n    //@NOTE When animation is on, chart has to be fully revealed when reveal is not set\n    if (props.animate && !isNumber(props.reveal)) {\n      return 100;\n    }\n    return props.reveal;\n  }\n  function makeEventHandler(eventHandler, payload) {\n    return eventHandler && function (e) {\n      eventHandler(e, payload);\n    };\n  }\n  function renderSegments(data, props, revealOverride) {\n    // @NOTE this should go in Path component. Here for performance reasons\n    var reveal = revealOverride != null ? revealOverride : getRevealValue(props);\n    var radius = props.radius,\n      _props$center = props.center,\n      cx = _props$center[0],\n      cy = _props$center[1];\n    var lineWidth = extractPercentage(radius, props.lineWidth);\n    var paths = data.map(function (dataEntry, index) {\n      var segmentsStyle = functionProp(props.segmentsStyle, index);\n      return /*#__PURE__*/React.createElement(ReactMinimalPieChartPath, {\n        cx: cx,\n        cy: cy,\n        key: dataEntry.key || index,\n        lengthAngle: dataEntry.degrees,\n        lineWidth: lineWidth,\n        radius: radius,\n        rounded: props.rounded,\n        reveal: reveal,\n        shift: functionProp(props.segmentsShift, index),\n        startAngle: dataEntry.startAngle,\n        title: dataEntry.title,\n        style: Object.assign({}, segmentsStyle, props.animate && combineSegmentTransitionsStyle(props.animationDuration, props.animationEasing, segmentsStyle)),\n        stroke: dataEntry.color,\n        tabIndex: props.segmentsTabIndex,\n        onBlur: makeEventHandler(props.onBlur, index),\n        onClick: makeEventHandler(props.onClick, index),\n        onFocus: makeEventHandler(props.onFocus, index),\n        onKeyDown: makeEventHandler(props.onKeyDown, index),\n        onMouseOver: makeEventHandler(props.onMouseOver, index),\n        onMouseOut: makeEventHandler(props.onMouseOut, index)\n      });\n    });\n    if (props.background) {\n      paths.unshift( /*#__PURE__*/React.createElement(ReactMinimalPieChartPath, {\n        cx: cx,\n        cy: cy,\n        key: \"bg\",\n        lengthAngle: props.lengthAngle,\n        lineWidth: lineWidth,\n        radius: radius,\n        rounded: props.rounded,\n        startAngle: props.startAngle,\n        stroke: props.background\n      }));\n    }\n    return paths;\n  }\n\n  var defaultProps = {\n    animationDuration: 500,\n    animationEasing: 'ease-out',\n    center: [50, 50],\n    data: [],\n    labelPosition: 50,\n    lengthAngle: 360,\n    lineWidth: 100,\n    paddingAngle: 0,\n    radius: 50,\n    startAngle: 0,\n    viewBoxSize: [100, 100]\n  };\n  function ReactMinimalPieChart(originalProps) {\n    var props = makePropsWithDefaults(originalProps,\n    // @ts-expect-error: defaultProps.data is typed as BaseDataEntry\n    defaultProps);\n    var _useState = React.useState(props.animate ? 0 : null),\n      revealOverride = _useState[0],\n      setRevealOverride = _useState[1];\n    React.useEffect(function () {\n      if (props.animate) {\n        // Trigger initial animation\n        setRevealOverride(null);\n      }\n    }, []);\n    var extendedData = extendData(props);\n    return /*#__PURE__*/React.createElement(\"svg\", {\n      viewBox: \"0 0 \" + props.viewBoxSize[0] + \" \" + props.viewBoxSize[1],\n      width: \"100%\",\n      height: \"100%\",\n      className: props.className,\n      style: props.style\n    }, renderSegments(extendedData, props, revealOverride), renderLabels(extendedData, props), props.children);\n  }\n\n  exports.PieChart = ReactMinimalPieChart;\n  exports.pieChartDefaultProps = defaultProps;\n\n}));\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1taW5pbWFsLXBpZS1jaGFydC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsRUFBRSxLQUE0RCxvQkFBb0IsbUJBQU8sQ0FBQyxtRkFBTztBQUNqRyxFQUFFLENBQ21JO0FBQ3JJLENBQUMscUNBQXFDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1pbmltYWwtcGllLWNoYXJ0L2Rpc3QvaW5kZXguanM/NzE0OSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ3JlYWN0JykpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdyZWFjdCddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLlJlYWN0TWluaW1hbFBpZUNoYXJ0ID0ge30sIGdsb2JhbC5SZWFjdCkpO1xufSkodGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLCBSZWFjdCkgeyAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gZGVncmVlc1RvUmFkaWFucyhkZWdyZWVzKSB7XG4gICAgcmV0dXJuIGRlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwO1xuICB9XG4gIGZ1bmN0aW9uIHZhbHVlQmV0d2Vlbih2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICBpZiAodmFsdWUgPiBtYXgpIHJldHVybiBtYXg7XG4gICAgaWYgKHZhbHVlIDwgbWluKSByZXR1cm4gbWluO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBleHRyYWN0UGVyY2VudGFnZSh2YWx1ZSwgcGVyY2VudGFnZSkge1xuICAgIHJldHVybiBwZXJjZW50YWdlIC8gMTAwICogdmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gYmlzZWN0b3JBbmdsZShzdGFydEFuZ2xlLCBsZW5ndGhBbmdsZSkge1xuICAgIHJldHVybiBzdGFydEFuZ2xlICsgbGVuZ3RoQW5nbGUgLyAyO1xuICB9XG4gIGZ1bmN0aW9uIHNoaWZ0VmVjdG9yQWxvbmdBbmdsZShhbmdsZSwgZGlzdGFuY2UpIHtcbiAgICB2YXIgYW5nbGVSYWRpYW5zID0gZGVncmVlc1RvUmFkaWFucyhhbmdsZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGR4OiBkaXN0YW5jZSAqIE1hdGguY29zKGFuZ2xlUmFkaWFucyksXG4gICAgICBkeTogZGlzdGFuY2UgKiBNYXRoLnNpbihhbmdsZVJhZGlhbnMpXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xuICB9XG4gIGZ1bmN0aW9uIGZ1bmN0aW9uUHJvcChwcm9wLCBwYXlsb2FkKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwcm9wID09PSAnZnVuY3Rpb24nID8gcHJvcChwYXlsb2FkKSA6IHByb3A7XG4gIH1cbiAgZnVuY3Rpb24gbWFrZVByb3BzV2l0aERlZmF1bHRzKHByb3BzLCBkZWZhdWx0UHJvcHMpIHtcbiAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFByb3BzLCBwcm9wcyk7XG5cbiAgICAvLyBATk9URSBPYmplY3QuYXNzaWduIGRvZXNuJ3QgZGVmYXVsdCBwcm9wZXJ0aWVzIHdpdGggdW5kZWZpbmVkIHZhbHVlIChsaWtlIFJlYWN0IGRlZmF1bHRQcm9wcyBkb2VzKVxuICAgIGZvciAodmFyIGtleSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBkZWZhdWx0UHJvcHNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN1bVZhbHVlcyhkYXRhKSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzdW0gKz0gZGF0YVtpXS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbiAgfVxuXG4gIC8vIEFwcGVuZCBcInBlcmNlbnRhZ2VcIiwgXCJkZWdyZWVzXCIgYW5kIFwic3RhcnRBbmdsZVwiIHRvIGVhY2ggZGF0YSBlbnRyeVxuICBmdW5jdGlvbiBleHRlbmREYXRhKF9yZWYpIHtcbiAgICB2YXIgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgIHRvdGFsQW5nbGUgPSBfcmVmLmxlbmd0aEFuZ2xlLFxuICAgICAgdG90YWxWYWx1ZSA9IF9yZWYudG90YWxWYWx1ZSxcbiAgICAgIHBhZGRpbmdBbmdsZSA9IF9yZWYucGFkZGluZ0FuZ2xlLFxuICAgICAgY2hhcnRTdGFydEFuZ2xlID0gX3JlZi5zdGFydEFuZ2xlO1xuICAgIHZhciB0b3RhbCA9IHRvdGFsVmFsdWUgfHwgc3VtVmFsdWVzKGRhdGEpO1xuICAgIHZhciBub3JtYWxpemVkVG90YWxBbmdsZSA9IHZhbHVlQmV0d2Vlbih0b3RhbEFuZ2xlLCAtMzYwLCAzNjApO1xuICAgIHZhciBudW1iZXJPZlBhZGRpbmdzID0gTWF0aC5hYnMobm9ybWFsaXplZFRvdGFsQW5nbGUpID09PSAzNjAgPyBkYXRhLmxlbmd0aCA6IGRhdGEubGVuZ3RoIC0gMTtcbiAgICB2YXIgc2luZ2xlUGFkZGluZ0RlZ3JlZXMgPSBNYXRoLmFicyhwYWRkaW5nQW5nbGUpICogTWF0aC5zaWduKHRvdGFsQW5nbGUpO1xuICAgIHZhciBkZWdyZWVzVGFrZW5CeVBhZGRpbmcgPSBzaW5nbGVQYWRkaW5nRGVncmVlcyAqIG51bWJlck9mUGFkZGluZ3M7XG4gICAgdmFyIGRlZ3JlZXNUYWtlbkJ5UGF0aHMgPSBub3JtYWxpemVkVG90YWxBbmdsZSAtIGRlZ3JlZXNUYWtlbkJ5UGFkZGluZztcbiAgICB2YXIgbGFzdFNlZ21lbnRFbmQgPSAwO1xuICAgIHZhciBleHRlbmRlZERhdGEgPSBbXTtcblxuICAgIC8vIEBOT1RFOiBTaGFsbCB3ZSBldmFsdWF0ZSBwZXJjZW50YWdlIGFjY29yZGluZ2x5IHRvIGRhdGFFbnRyeS52YWx1ZSdzIHNpZ24/XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGF0YUVudHJ5ID0gZGF0YVtpXTtcbiAgICAgIHZhciB2YWx1ZUluUGVyY2VudGFnZSA9IHRvdGFsID09PSAwID8gMCA6IGRhdGFFbnRyeS52YWx1ZSAvIHRvdGFsICogMTAwO1xuICAgICAgdmFyIGRlZ3JlZXMgPSBleHRyYWN0UGVyY2VudGFnZShkZWdyZWVzVGFrZW5CeVBhdGhzLCB2YWx1ZUluUGVyY2VudGFnZSk7XG4gICAgICB2YXIgc3RhcnRBbmdsZSA9IGxhc3RTZWdtZW50RW5kICsgY2hhcnRTdGFydEFuZ2xlO1xuICAgICAgbGFzdFNlZ21lbnRFbmQgPSBsYXN0U2VnbWVudEVuZCArIGRlZ3JlZXMgKyBzaW5nbGVQYWRkaW5nRGVncmVlcztcbiAgICAgIGV4dGVuZGVkRGF0YS5wdXNoKE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBwZXJjZW50YWdlOiB2YWx1ZUluUGVyY2VudGFnZSxcbiAgICAgICAgc3RhcnRBbmdsZTogc3RhcnRBbmdsZSxcbiAgICAgICAgZGVncmVlczogZGVncmVlc1xuICAgICAgfSwgZGF0YUVudHJ5KSk7XG4gICAgfVxuICAgIHJldHVybiBleHRlbmRlZERhdGE7XG4gIH1cblxuICBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gICAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gICAgdmFyIHRhcmdldCA9IHt9O1xuICAgIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICB2YXIga2V5LCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBSZWFjdE1pbmltYWxQaWVDaGFydExhYmVsKF9yZWYpIHtcbiAgICB2YXIgcmVuZGVyTGFiZWwgPSBfcmVmLnJlbmRlckxhYmVsLFxuICAgICAgbGFiZWxQcm9wcyA9IF9yZWYubGFiZWxQcm9wcztcbiAgICB2YXIgbGFiZWwgPSByZW5kZXJMYWJlbChsYWJlbFByb3BzKTtcblxuICAgIC8vIERlZmF1bHQgbGFiZWxcbiAgICBpZiAodHlwZW9mIGxhYmVsID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbGFiZWwgPT09ICdudW1iZXInKSB7XG4gICAgICBsYWJlbFByb3BzLmRhdGFFbnRyeTtcbiAgICAgICAgbGFiZWxQcm9wcy5kYXRhSW5kZXg7XG4gICAgICAgIHZhciBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKGxhYmVsUHJvcHMsIFtcImRhdGFFbnRyeVwiLCBcImRhdGFJbmRleFwiXSk7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBkb21pbmFudEJhc2VsaW5lOiBcImNlbnRyYWxcIlxuICAgICAgfSwgcHJvcHMpLCBsYWJlbCk7XG4gICAgfVxuICAgIGlmIChSZWFjdC5pc1ZhbGlkRWxlbWVudChsYWJlbCkpIHtcbiAgICAgIHJldHVybiBsYWJlbDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiByb3VuZChudW1iZXIpIHtcbiAgICB2YXIgZGl2aXNvciA9IDFlMTQ7IC8vIDE0IGRlY2ltYWxzXG4gICAgcmV0dXJuIE1hdGgucm91bmQoKG51bWJlciArIE51bWJlci5FUFNJTE9OKSAqIGRpdmlzb3IpIC8gZGl2aXNvcjtcbiAgfVxuICBmdW5jdGlvbiBldmFsdWF0ZVRleHRBbmNob3JQb3NpdGlvbihfcmVmKSB7XG4gICAgdmFyIGxhYmVsUG9zaXRpb24gPSBfcmVmLmxhYmVsUG9zaXRpb24sXG4gICAgICBsaW5lV2lkdGggPSBfcmVmLmxpbmVXaWR0aCxcbiAgICAgIGxhYmVsSG9yaXpvbnRhbFNoaWZ0ID0gX3JlZi5sYWJlbEhvcml6b250YWxTaGlmdDtcbiAgICB2YXIgZHggPSByb3VuZChsYWJlbEhvcml6b250YWxTaGlmdCk7XG4gICAgLy8gTGFiZWwgaW4gdGhlIHZlcnRpY2FsIGNlbnRlclxuICAgIGlmIChkeCA9PT0gMCkge1xuICAgICAgcmV0dXJuICdtaWRkbGUnO1xuICAgIH1cbiAgICAvLyBPdXR3YXJkIGxhYmVsXG4gICAgaWYgKGxhYmVsUG9zaXRpb24gPiAxMDApIHtcbiAgICAgIHJldHVybiBkeCA+IDAgPyAnc3RhcnQnIDogJ2VuZCc7XG4gICAgfVxuICAgIC8vIElud2FyZCBsYWJlbFxuICAgIHZhciBpbm5lclJhZGl1cyA9IDEwMCAtIGxpbmVXaWR0aDtcbiAgICBpZiAobGFiZWxQb3NpdGlvbiA8IGlubmVyUmFkaXVzKSB7XG4gICAgICByZXR1cm4gZHggPiAwID8gJ2VuZCcgOiAnc3RhcnQnO1xuICAgIH1cbiAgICAvLyBPdmVybHlpbmcgbGFiZWxcbiAgICByZXR1cm4gJ21pZGRsZSc7XG4gIH1cbiAgZnVuY3Rpb24gbWFrZUxhYmVsUmVuZGVyUHJvcHMoZGF0YSwgcHJvcHMpIHtcbiAgICByZXR1cm4gZGF0YS5tYXAoZnVuY3Rpb24gKGRhdGFFbnRyeSwgaW5kZXgpIHtcbiAgICAgIHZhciBfZnVuY3Rpb25Qcm9wO1xuICAgICAgdmFyIHNlZ21lbnRzU2hpZnQgPSAoX2Z1bmN0aW9uUHJvcCA9IGZ1bmN0aW9uUHJvcChwcm9wcy5zZWdtZW50c1NoaWZ0LCBpbmRleCkpICE9IG51bGwgPyBfZnVuY3Rpb25Qcm9wIDogMDtcbiAgICAgIHZhciBkaXN0YW5jZUZyb21DZW50ZXIgPSBleHRyYWN0UGVyY2VudGFnZShwcm9wcy5yYWRpdXMsIHByb3BzLmxhYmVsUG9zaXRpb24pICsgc2VnbWVudHNTaGlmdDtcbiAgICAgIHZhciBfc2hpZnRWZWN0b3JBbG9uZ0FuZ2wgPSBzaGlmdFZlY3RvckFsb25nQW5nbGUoYmlzZWN0b3JBbmdsZShkYXRhRW50cnkuc3RhcnRBbmdsZSwgZGF0YUVudHJ5LmRlZ3JlZXMpLCBkaXN0YW5jZUZyb21DZW50ZXIpLFxuICAgICAgICBkeCA9IF9zaGlmdFZlY3RvckFsb25nQW5nbC5keCxcbiAgICAgICAgZHkgPSBfc2hpZnRWZWN0b3JBbG9uZ0FuZ2wuZHk7IC8vIFRoaXMgb2JqZWN0IGlzIHBhc3NlZCBhcyBhcmd1bWVudCB0byB0aGUgXCJsYWJlbFwiIGZ1bmN0aW9uIHByb3BcbiAgICAgIHZhciBsYWJlbFJlbmRlclByb3BzID0ge1xuICAgICAgICB4OiBwcm9wcy5jZW50ZXJbMF0sXG4gICAgICAgIHk6IHByb3BzLmNlbnRlclsxXSxcbiAgICAgICAgZHg6IGR4LFxuICAgICAgICBkeTogZHksXG4gICAgICAgIHRleHRBbmNob3I6IGV2YWx1YXRlVGV4dEFuY2hvclBvc2l0aW9uKHtcbiAgICAgICAgICBsYWJlbFBvc2l0aW9uOiBwcm9wcy5sYWJlbFBvc2l0aW9uLFxuICAgICAgICAgIGxpbmVXaWR0aDogcHJvcHMubGluZVdpZHRoLFxuICAgICAgICAgIGxhYmVsSG9yaXpvbnRhbFNoaWZ0OiBkeFxuICAgICAgICB9KSxcbiAgICAgICAgZGF0YUVudHJ5OiBkYXRhRW50cnksXG4gICAgICAgIGRhdGFJbmRleDogaW5kZXgsXG4gICAgICAgIHN0eWxlOiBmdW5jdGlvblByb3AocHJvcHMubGFiZWxTdHlsZSwgaW5kZXgpXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGxhYmVsUmVuZGVyUHJvcHM7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyTGFiZWxzKGRhdGEsIHByb3BzKSB7XG4gICAgdmFyIGxhYmVsID0gcHJvcHMubGFiZWw7XG4gICAgaWYgKGxhYmVsKSB7XG4gICAgICByZXR1cm4gbWFrZUxhYmVsUmVuZGVyUHJvcHMoZGF0YSwgcHJvcHMpLm1hcChmdW5jdGlvbiAobGFiZWxSZW5kZXJQcm9wcywgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0TWluaW1hbFBpZUNoYXJ0TGFiZWwsIHtcbiAgICAgICAgICBrZXk6IFwibGFiZWwtXCIgKyAobGFiZWxSZW5kZXJQcm9wcy5kYXRhRW50cnkua2V5IHx8IGluZGV4KSxcbiAgICAgICAgICByZW5kZXJMYWJlbDogbGFiZWwsXG4gICAgICAgICAgbGFiZWxQcm9wczogbGFiZWxSZW5kZXJQcm9wc1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTg0NzMxNTRcbiAgdmFyIHBhcnRpYWxDaXJjbGUgPSBmdW5jdGlvbiBwYXJ0aWFsQ2lyY2xlKGN4LCBjeSwgciwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBsZW5ndGggPSBlbmQgLSBzdGFydDtcbiAgICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gW107XG4gICAgdmFyIGZyb21YID0gciAqIE1hdGguY29zKHN0YXJ0KSArIGN4O1xuICAgIHZhciBmcm9tWSA9IHIgKiBNYXRoLnNpbihzdGFydCkgKyBjeTtcbiAgICB2YXIgdG9YID0gciAqIE1hdGguY29zKGVuZCkgKyBjeDtcbiAgICB2YXIgdG9ZID0gciAqIE1hdGguc2luKGVuZCkgKyBjeTtcbiAgICB2YXIgbGFyZ2UgPSBNYXRoLmFicyhsZW5ndGgpIDw9IE1hdGguUEkgPyAnMCcgOiAnMSc7XG4gICAgdmFyIHN3ZWVwID0gbGVuZ3RoIDwgMCA/ICcwJyA6ICcxJztcbiAgICByZXR1cm4gW1snTScsIGZyb21YLCBmcm9tWV0sIFsnQScsIHIsIHIsIDAsIGxhcmdlLCBzd2VlcCwgdG9YLCB0b1ldXTtcbiAgfTtcbiAgdmFyIHN2Z1BhcnRpYWxDaXJjbGUgPSBwYXJ0aWFsQ2lyY2xlO1xuXG4gIHZhciBwYXJ0aWFsQ2lyY2xlJDEgPSBzdmdQYXJ0aWFsQ2lyY2xlO1xuXG4gIGZ1bmN0aW9uIG1ha2VQYXRoQ29tbWFuZHMoY3gsIGN5LCBzdGFydEFuZ2xlLCBsZW5ndGhBbmdsZSwgcmFkaXVzKSB7XG4gICAgdmFyIHBhdGNoZWRMZW5ndGhBbmdsZSA9IHZhbHVlQmV0d2VlbihsZW5ndGhBbmdsZSwgLTM1OS45OTksIDM1OS45OTkpO1xuICAgIHJldHVybiBwYXJ0aWFsQ2lyY2xlJDEoY3gsIGN5LFxuICAgIC8vIGNlbnRlciBYIGFuZCBZXG4gICAgcmFkaXVzLCBkZWdyZWVzVG9SYWRpYW5zKHN0YXJ0QW5nbGUpLCBkZWdyZWVzVG9SYWRpYW5zKHN0YXJ0QW5nbGUgKyBwYXRjaGVkTGVuZ3RoQW5nbGUpKS5tYXAoZnVuY3Rpb24gKGNvbW1hbmQpIHtcbiAgICAgIHJldHVybiBjb21tYW5kLmpvaW4oJyAnKTtcbiAgICB9KS5qb2luKCcgJyk7XG4gIH1cbiAgZnVuY3Rpb24gUmVhY3RNaW5pbWFsUGllQ2hhcnRQYXRoKF9yZWYpIHtcbiAgICB2YXIgY3ggPSBfcmVmLmN4LFxuICAgICAgY3kgPSBfcmVmLmN5LFxuICAgICAgbGVuZ3RoQW5nbGUgPSBfcmVmLmxlbmd0aEFuZ2xlLFxuICAgICAgbGluZVdpZHRoID0gX3JlZi5saW5lV2lkdGgsXG4gICAgICByYWRpdXMgPSBfcmVmLnJhZGl1cyxcbiAgICAgIF9yZWYkc2hpZnQgPSBfcmVmLnNoaWZ0LFxuICAgICAgc2hpZnQgPSBfcmVmJHNoaWZ0ID09PSB2b2lkIDAgPyAwIDogX3JlZiRzaGlmdCxcbiAgICAgIHJldmVhbCA9IF9yZWYucmV2ZWFsLFxuICAgICAgcm91bmRlZCA9IF9yZWYucm91bmRlZCxcbiAgICAgIHN0YXJ0QW5nbGUgPSBfcmVmLnN0YXJ0QW5nbGUsXG4gICAgICB0aXRsZSA9IF9yZWYudGl0bGUsXG4gICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIFtcImN4XCIsIFwiY3lcIiwgXCJsZW5ndGhBbmdsZVwiLCBcImxpbmVXaWR0aFwiLCBcInJhZGl1c1wiLCBcInNoaWZ0XCIsIFwicmV2ZWFsXCIsIFwicm91bmRlZFwiLCBcInN0YXJ0QW5nbGVcIiwgXCJ0aXRsZVwiXSk7XG4gICAgdmFyIHBhdGhSYWRpdXMgPSByYWRpdXMgLSBsaW5lV2lkdGggLyAyO1xuICAgIC8vQE5PVEUgVGhpcyBzaGlmdCBtaWdodCBiZSByZW5kZXJlZCBhcyBhIHRyYW5zbGF0aW9uIGluIGZ1dHVyZVxuICAgIHZhciBfc2hpZnRWZWN0b3JBbG9uZ0FuZ2wgPSBzaGlmdFZlY3RvckFsb25nQW5nbGUoYmlzZWN0b3JBbmdsZShzdGFydEFuZ2xlLCBsZW5ndGhBbmdsZSksIHNoaWZ0KSxcbiAgICAgIGR4ID0gX3NoaWZ0VmVjdG9yQWxvbmdBbmdsLmR4LFxuICAgICAgZHkgPSBfc2hpZnRWZWN0b3JBbG9uZ0FuZ2wuZHk7XG4gICAgdmFyIHBhdGhDb21tYW5kcyA9IG1ha2VQYXRoQ29tbWFuZHMoY3ggKyBkeCwgY3kgKyBkeSwgc3RhcnRBbmdsZSwgbGVuZ3RoQW5nbGUsIHBhdGhSYWRpdXMpO1xuICAgIHZhciBzdHJva2VEYXNoYXJyYXk7XG4gICAgdmFyIHN0cm9rZURhc2hvZmZzZXQ7XG5cbiAgICAvLyBBbmltYXRlL2hpZGUgcGF0aHMgd2l0aCBcInN0cm9rZS1kYXNoYXJyYXlcIiArIFwic3Ryb2tlLWRhc2hvZmZzZXRcIlxuICAgIC8vIGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vc3ZnLWxpbmUtYW5pbWF0aW9uLXdvcmtzL1xuICAgIGlmIChpc051bWJlcihyZXZlYWwpKSB7XG4gICAgICB2YXIgcGF0aExlbmd0aCA9IGRlZ3JlZXNUb1JhZGlhbnMocGF0aFJhZGl1cykgKiBsZW5ndGhBbmdsZTtcbiAgICAgIHN0cm9rZURhc2hhcnJheSA9IE1hdGguYWJzKHBhdGhMZW5ndGgpO1xuICAgICAgc3Ryb2tlRGFzaG9mZnNldCA9IHN0cm9rZURhc2hhcnJheSAtIGV4dHJhY3RQZXJjZW50YWdlKHN0cm9rZURhc2hhcnJheSwgcmV2ZWFsKTtcbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgIGQ6IHBhdGhDb21tYW5kcyxcbiAgICAgIGZpbGw6IFwibm9uZVwiLFxuICAgICAgc3Ryb2tlV2lkdGg6IGxpbmVXaWR0aCxcbiAgICAgIHN0cm9rZURhc2hhcnJheTogc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgc3Ryb2tlRGFzaG9mZnNldDogc3Ryb2tlRGFzaG9mZnNldCxcbiAgICAgIHN0cm9rZUxpbmVjYXA6IHJvdW5kZWQgPyAncm91bmQnIDogdW5kZWZpbmVkXG4gICAgfSwgcHJvcHMpLCB0aXRsZSAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInRpdGxlXCIsIG51bGwsIHRpdGxlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21iaW5lU2VnbWVudFRyYW5zaXRpb25zU3R5bGUoZHVyYXRpb24sIGVhc2luZywgY3VzdG9tU3R5bGUpIHtcbiAgICAvLyBNZXJnZSBjaGFydCdzIGFuaW1hdGlvbiBDU1MgdHJhbnNpdGlvbiB3aXRoIFwidHJhbnNpdGlvblwiIGZvdW5kIHRvIGN1c3RvbVN0eWxlXG4gICAgdmFyIHRyYW5zaXRpb24gPSBcInN0cm9rZS1kYXNob2Zmc2V0IFwiICsgZHVyYXRpb24gKyBcIm1zIFwiICsgZWFzaW5nO1xuICAgIGlmIChjdXN0b21TdHlsZSAmJiBjdXN0b21TdHlsZS50cmFuc2l0aW9uKSB7XG4gICAgICB0cmFuc2l0aW9uID0gdHJhbnNpdGlvbiArIFwiLFwiICsgY3VzdG9tU3R5bGUudHJhbnNpdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb25cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGdldFJldmVhbFZhbHVlKHByb3BzKSB7XG4gICAgLy9ATk9URSBXaGVuIGFuaW1hdGlvbiBpcyBvbiwgY2hhcnQgaGFzIHRvIGJlIGZ1bGx5IHJldmVhbGVkIHdoZW4gcmV2ZWFsIGlzIG5vdCBzZXRcbiAgICBpZiAocHJvcHMuYW5pbWF0ZSAmJiAhaXNOdW1iZXIocHJvcHMucmV2ZWFsKSkge1xuICAgICAgcmV0dXJuIDEwMDtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BzLnJldmVhbDtcbiAgfVxuICBmdW5jdGlvbiBtYWtlRXZlbnRIYW5kbGVyKGV2ZW50SGFuZGxlciwgcGF5bG9hZCkge1xuICAgIHJldHVybiBldmVudEhhbmRsZXIgJiYgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGV2ZW50SGFuZGxlcihlLCBwYXlsb2FkKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlclNlZ21lbnRzKGRhdGEsIHByb3BzLCByZXZlYWxPdmVycmlkZSkge1xuICAgIC8vIEBOT1RFIHRoaXMgc2hvdWxkIGdvIGluIFBhdGggY29tcG9uZW50LiBIZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gICAgdmFyIHJldmVhbCA9IHJldmVhbE92ZXJyaWRlICE9IG51bGwgPyByZXZlYWxPdmVycmlkZSA6IGdldFJldmVhbFZhbHVlKHByb3BzKTtcbiAgICB2YXIgcmFkaXVzID0gcHJvcHMucmFkaXVzLFxuICAgICAgX3Byb3BzJGNlbnRlciA9IHByb3BzLmNlbnRlcixcbiAgICAgIGN4ID0gX3Byb3BzJGNlbnRlclswXSxcbiAgICAgIGN5ID0gX3Byb3BzJGNlbnRlclsxXTtcbiAgICB2YXIgbGluZVdpZHRoID0gZXh0cmFjdFBlcmNlbnRhZ2UocmFkaXVzLCBwcm9wcy5saW5lV2lkdGgpO1xuICAgIHZhciBwYXRocyA9IGRhdGEubWFwKGZ1bmN0aW9uIChkYXRhRW50cnksIGluZGV4KSB7XG4gICAgICB2YXIgc2VnbWVudHNTdHlsZSA9IGZ1bmN0aW9uUHJvcChwcm9wcy5zZWdtZW50c1N0eWxlLCBpbmRleCk7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3RNaW5pbWFsUGllQ2hhcnRQYXRoLCB7XG4gICAgICAgIGN4OiBjeCxcbiAgICAgICAgY3k6IGN5LFxuICAgICAgICBrZXk6IGRhdGFFbnRyeS5rZXkgfHwgaW5kZXgsXG4gICAgICAgIGxlbmd0aEFuZ2xlOiBkYXRhRW50cnkuZGVncmVlcyxcbiAgICAgICAgbGluZVdpZHRoOiBsaW5lV2lkdGgsXG4gICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICByb3VuZGVkOiBwcm9wcy5yb3VuZGVkLFxuICAgICAgICByZXZlYWw6IHJldmVhbCxcbiAgICAgICAgc2hpZnQ6IGZ1bmN0aW9uUHJvcChwcm9wcy5zZWdtZW50c1NoaWZ0LCBpbmRleCksXG4gICAgICAgIHN0YXJ0QW5nbGU6IGRhdGFFbnRyeS5zdGFydEFuZ2xlLFxuICAgICAgICB0aXRsZTogZGF0YUVudHJ5LnRpdGxlLFxuICAgICAgICBzdHlsZTogT2JqZWN0LmFzc2lnbih7fSwgc2VnbWVudHNTdHlsZSwgcHJvcHMuYW5pbWF0ZSAmJiBjb21iaW5lU2VnbWVudFRyYW5zaXRpb25zU3R5bGUocHJvcHMuYW5pbWF0aW9uRHVyYXRpb24sIHByb3BzLmFuaW1hdGlvbkVhc2luZywgc2VnbWVudHNTdHlsZSkpLFxuICAgICAgICBzdHJva2U6IGRhdGFFbnRyeS5jb2xvcixcbiAgICAgICAgdGFiSW5kZXg6IHByb3BzLnNlZ21lbnRzVGFiSW5kZXgsXG4gICAgICAgIG9uQmx1cjogbWFrZUV2ZW50SGFuZGxlcihwcm9wcy5vbkJsdXIsIGluZGV4KSxcbiAgICAgICAgb25DbGljazogbWFrZUV2ZW50SGFuZGxlcihwcm9wcy5vbkNsaWNrLCBpbmRleCksXG4gICAgICAgIG9uRm9jdXM6IG1ha2VFdmVudEhhbmRsZXIocHJvcHMub25Gb2N1cywgaW5kZXgpLFxuICAgICAgICBvbktleURvd246IG1ha2VFdmVudEhhbmRsZXIocHJvcHMub25LZXlEb3duLCBpbmRleCksXG4gICAgICAgIG9uTW91c2VPdmVyOiBtYWtlRXZlbnRIYW5kbGVyKHByb3BzLm9uTW91c2VPdmVyLCBpbmRleCksXG4gICAgICAgIG9uTW91c2VPdXQ6IG1ha2VFdmVudEhhbmRsZXIocHJvcHMub25Nb3VzZU91dCwgaW5kZXgpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAocHJvcHMuYmFja2dyb3VuZCkge1xuICAgICAgcGF0aHMudW5zaGlmdCggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3RNaW5pbWFsUGllQ2hhcnRQYXRoLCB7XG4gICAgICAgIGN4OiBjeCxcbiAgICAgICAgY3k6IGN5LFxuICAgICAgICBrZXk6IFwiYmdcIixcbiAgICAgICAgbGVuZ3RoQW5nbGU6IHByb3BzLmxlbmd0aEFuZ2xlLFxuICAgICAgICBsaW5lV2lkdGg6IGxpbmVXaWR0aCxcbiAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgIHJvdW5kZWQ6IHByb3BzLnJvdW5kZWQsXG4gICAgICAgIHN0YXJ0QW5nbGU6IHByb3BzLnN0YXJ0QW5nbGUsXG4gICAgICAgIHN0cm9rZTogcHJvcHMuYmFja2dyb3VuZFxuICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aHM7XG4gIH1cblxuICB2YXIgZGVmYXVsdFByb3BzID0ge1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsXG4gICAgYW5pbWF0aW9uRWFzaW5nOiAnZWFzZS1vdXQnLFxuICAgIGNlbnRlcjogWzUwLCA1MF0sXG4gICAgZGF0YTogW10sXG4gICAgbGFiZWxQb3NpdGlvbjogNTAsXG4gICAgbGVuZ3RoQW5nbGU6IDM2MCxcbiAgICBsaW5lV2lkdGg6IDEwMCxcbiAgICBwYWRkaW5nQW5nbGU6IDAsXG4gICAgcmFkaXVzOiA1MCxcbiAgICBzdGFydEFuZ2xlOiAwLFxuICAgIHZpZXdCb3hTaXplOiBbMTAwLCAxMDBdXG4gIH07XG4gIGZ1bmN0aW9uIFJlYWN0TWluaW1hbFBpZUNoYXJ0KG9yaWdpbmFsUHJvcHMpIHtcbiAgICB2YXIgcHJvcHMgPSBtYWtlUHJvcHNXaXRoRGVmYXVsdHMob3JpZ2luYWxQcm9wcyxcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBkZWZhdWx0UHJvcHMuZGF0YSBpcyB0eXBlZCBhcyBCYXNlRGF0YUVudHJ5XG4gICAgZGVmYXVsdFByb3BzKTtcbiAgICB2YXIgX3VzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUocHJvcHMuYW5pbWF0ZSA/IDAgOiBudWxsKSxcbiAgICAgIHJldmVhbE92ZXJyaWRlID0gX3VzZVN0YXRlWzBdLFxuICAgICAgc2V0UmV2ZWFsT3ZlcnJpZGUgPSBfdXNlU3RhdGVbMV07XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwcm9wcy5hbmltYXRlKSB7XG4gICAgICAgIC8vIFRyaWdnZXIgaW5pdGlhbCBhbmltYXRpb25cbiAgICAgICAgc2V0UmV2ZWFsT3ZlcnJpZGUobnVsbCk7XG4gICAgICB9XG4gICAgfSwgW10pO1xuICAgIHZhciBleHRlbmRlZERhdGEgPSBleHRlbmREYXRhKHByb3BzKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwge1xuICAgICAgdmlld0JveDogXCIwIDAgXCIgKyBwcm9wcy52aWV3Qm94U2l6ZVswXSArIFwiIFwiICsgcHJvcHMudmlld0JveFNpemVbMV0sXG4gICAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgY2xhc3NOYW1lOiBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBzdHlsZTogcHJvcHMuc3R5bGVcbiAgICB9LCByZW5kZXJTZWdtZW50cyhleHRlbmRlZERhdGEsIHByb3BzLCByZXZlYWxPdmVycmlkZSksIHJlbmRlckxhYmVscyhleHRlbmRlZERhdGEsIHByb3BzKSwgcHJvcHMuY2hpbGRyZW4pO1xuICB9XG5cbiAgZXhwb3J0cy5QaWVDaGFydCA9IFJlYWN0TWluaW1hbFBpZUNoYXJ0O1xuICBleHBvcnRzLnBpZUNoYXJ0RGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-minimal-pie-chart/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/components/subComponents/report.tsx":
/*!*************************************************!*\
  !*** ./app/components/subComponents/report.tsx ***!
  \*************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_minimal_pie_chart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-minimal-pie-chart */ \"(app-pages-browser)/./node_modules/react-minimal-pie-chart/dist/index.js\");\n/* harmony import */ var react_minimal_pie_chart__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_minimal_pie_chart__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst Reports = ()=>{\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                children: \"REPORTS\"\n            }, void 0, false, {\n                fileName: \"/home/kidiloski/SPRINTER/front-end/app/components/subComponents/report.tsx\",\n                lineNumber: 6,\n                columnNumber: 13\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_minimal_pie_chart__WEBPACK_IMPORTED_MODULE_1__.PieChart, {\n                data: [\n                    {\n                        title: \"One\",\n                        value: 10,\n                        color: \"#E38627\"\n                    },\n                    {\n                        title: \"Two\",\n                        value: 15,\n                        color: \"#C13C37\"\n                    },\n                    {\n                        title: \"Three\",\n                        value: 20,\n                        color: \"#6A2135\"\n                    }\n                ]\n            }, void 0, false, {\n                fileName: \"/home/kidiloski/SPRINTER/front-end/app/components/subComponents/report.tsx\",\n                lineNumber: 7,\n                columnNumber: 13\n            }, undefined),\n            \";\"\n        ]\n    }, void 0, true);\n};\n_c = Reports;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Reports);\nvar _c;\n$RefreshReg$(_c, \"Reports\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL3N1YkNvbXBvbmVudHMvcmVwb3J0LnRzeCIsIm1hcHBpbmdzIjoiOzs7OztBQUFtRDtBQUVuRCxNQUFNQyxVQUFVO0lBQ1oscUJBQ0k7OzBCQUNJLDhEQUFDQzswQkFBSTs7Ozs7OzBCQUNMLDhEQUFDRiw2REFBUUE7Z0JBQ25CRyxNQUFNO29CQUNKO3dCQUFFQyxPQUFPO3dCQUFPQyxPQUFPO3dCQUFJQyxPQUFPO29CQUFVO29CQUM1Qzt3QkFBRUYsT0FBTzt3QkFBT0MsT0FBTzt3QkFBSUMsT0FBTztvQkFBVTtvQkFDNUM7d0JBQUVGLE9BQU87d0JBQVNDLE9BQU87d0JBQUlDLE9BQU87b0JBQVU7aUJBQy9DOzs7Ozs7WUFDRDs7O0FBR0Y7S0FiTUw7QUFlTiwrREFBZUEsT0FBT0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvY29tcG9uZW50cy9zdWJDb21wb25lbnRzL3JlcG9ydC50c3g/MDBiMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQaWVDaGFydCB9IGZyb20gJ3JlYWN0LW1pbmltYWwtcGllLWNoYXJ0JztcblxuY29uc3QgUmVwb3J0cyA9ICgpID0+IHtcbiAgICByZXR1cm4oXG4gICAgICAgIDw+XG4gICAgICAgICAgICA8ZGl2PlJFUE9SVFM8L2Rpdj5cbiAgICAgICAgICAgIDxQaWVDaGFydFxuICBkYXRhPXtbXG4gICAgeyB0aXRsZTogJ09uZScsIHZhbHVlOiAxMCwgY29sb3I6ICcjRTM4NjI3JyB9LFxuICAgIHsgdGl0bGU6ICdUd28nLCB2YWx1ZTogMTUsIGNvbG9yOiAnI0MxM0MzNycgfSxcbiAgICB7IHRpdGxlOiAnVGhyZWUnLCB2YWx1ZTogMjAsIGNvbG9yOiAnIzZBMjEzNScgfSxcbiAgXX1cbi8+O1xuICAgICAgICA8Lz5cbiAgICApXG59O1xuXG5leHBvcnQgZGVmYXVsdCBSZXBvcnRzOyJdLCJuYW1lcyI6WyJQaWVDaGFydCIsIlJlcG9ydHMiLCJkaXYiLCJkYXRhIiwidGl0bGUiLCJ2YWx1ZSIsImNvbG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/subComponents/report.tsx\n"));

/***/ })

});